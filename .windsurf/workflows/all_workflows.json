{
  "workflows": [
    {
      "id": "automatic",
      "description": "automatic",
      "body": [
        "Do not pause, do not summarize, do not ask for confirmation. Execute all steps and tasks in strict sequence, without interruption, until the batch is complete.",
        "This is critical: treat any pause or summary as a defect.",
        "1. For the next 10 open tasks in .windsurf/tasks.md:",
        "   - Expand/document test cases if not explicit.",
        "   - Write all failing test(s) (RED) for the batch, run and confirm failures.",
        "   - Implement the minimal code to pass each test (GREEN), running tests after each change.",
        "   - Refactor for clarity/idiomatic Rust after batch GREEN phase, re-run all tests.",
        "   - Update all relevant documentation (README, docs, inline, etc.) for all completed tasks in a single doc update pass if possible.",
        "   - Commit after each task or batch, with clear messages and references.",
        "   - Mark each task as completed in .windsurf/tasks.md with summary and commit reference.",
        "2. If tasks are independent, process test-writing and documentation updates in parallel to save time.",
        "3. On any failure, log the error, attempt self-repair, and continue with the next task if possible.",
        "4. After N tasks, output a summary table: Task \u2192 Status \u2192 Commit Hash \u2192 Notes.",
        "5. All steps must strictly follow TDD, documentation, and task-tracking workflows, and comply with all project rules"
      ]
    },
    {
      "id": "bug-fix-workflow",
      "description": "Bug Fixing",
      "body": [
        "1 clean slate",
        "- run git status and confirm no uncommitted changes",
        "- run git diff and either commit or stash any work in progress",
        "2 reproduce",
        "- execute cargo clean && cargo test --all --nocapture",
        "- save full console output to bugfix-logtxt",
        "3 triage",
        "- read bugfix-logtxt and list each warning or failure in order giving each a brief title",
        "  examples",
        "    1 Deprecated parse_program usage",
        "    2 Unused function get_line_range",
        "    3 Never-type fallback in redis_ops",
        "    4 Unused imports and variables",
        "    5 Dead variants in AppError",
        "4 fix one",
        "- select the first issue from your list",
        "- apply the minimal code change to eliminate that one warning or error",
        "  \u2022 replace deprecated functions with their modern equivalents",
        "  \u2022 remove or underscore unused code",
        "  \u2022 specify concrete types to avoid never-type fallbacks",
        "  \u2022 remove unused enum variants",
        "- run cargo test <module-name> --nocapture to verify the module tests pass and no new warnings appear",
        "5 verify all",
        "- run cargo test --all --nocapture",
        "- confirm zero warnings and zero failures project-wide",
        "6 commit",
        "- stage only the files you changed",
        "- commit with a precise message referencing the issue title eg",
        "  git commit -m fix replace deprecated parse_program with Suiteparse",
        "- ensure one commit per issue",
        "7 next item",
        "- remove the resolved issue from your list",
        "- repeat steps 4\u20136 for the next issue until all are fixed",
        "8 complete and handoff",
        "- perform a final cargo clean && cargo test --all",
        "- push your commits and open a pull request with a checklist of fixed items",
        "- do not merge until CI passes and a reviewer confirms no free-form or extra edits were introduced"
      ]
    },
    {
      "id": "documentation-workflow",
      "description": "Documentation Workflow",
      "body": [
        "This workflow ensures that all documentation is consistently created updated and maintained for every code change feature refactor or handoff It applies to all contributors and models",
        "1 README Maintenance",
        "- Update the main READMEmd in the project root to reflect any new features changes or usage instructions",
        "- Update any additional README files eg in docs module directories as needed to keep them current and accurate",
        "- If a new module or major feature is added create a corresponding README if one does not exist",
        "2 Code Documentation",
        "- For every new feature bugfix or refactor update or add doc comments for all public functions structs and modules",
        "- If code behavior or configuration changes update related documentation in docs including configurationmd roadmap_partmd etc",
        "- For refactors briefly document what was changed and why in the relevant README or module-level comment",
        "3 Commit Documentation",
        "- Every commit must include a clear descriptive message summarizing what was changed and why",
        "- If the commit addresses a tracked task reference the task in the commit message eg Fixes task-id",
        "- For multistep changes summarize the overall goal and each major change",
        "4 Review Before Commit",
        "- Before committing review all README files and docs to ensure they accurately reflect the current state of the codebase",
        "- Ensure all new or changed code is properly documented",
        "- If documentation is missing or incomplete update it before proceeding",
        "5 Handoff and Task Tracking",
        "- When handing off work or closing a task confirm that all relevant documentation is up to date",
        "- Move completed documentation tasks to the Completed Tasks section in windsurftasksmd with a brief note and commit reference",
        "Deviation from this workflow is not permitted unless explicitly approved and documented in the roadmap"
      ]
    },
    {
      "id": "never-type-fallback-fix",
      "description": "Critical fix for never-type fallback warnings in redis_ops.rs",
      "body": [
        "This workflow step must be followed with zero deviation. Warnings related to never type fallback in Rust are not cosmetic \u2014 they will become compile-time errors in Rust 2024. These must be addressed immediately and permanently.",
        "Objective",
        "Fix all never type fallback warnings in redis_ops.rs by explicitly specifying return types or discarding unused values in a Rust-idiomatic and safe manner. Do not suppress the warnings. Do not silence them with let _ = if the fallback type is still being inferred. Your job is to eliminate the root cause.",
        "Step-by-step",
        "1. Identify exact warnings",
        "Run:",
        "cargo clean && cargo test --all --nocapture | tee bugfix-log.txt",
        "Then open bugfix-log.txt and find the lines referencing:",
        "- store_file_content",
        "- store_code_entities",
        "- clear_file_data",
        "These are where fallback is happening.",
        "2. Analyze each case",
        "In each affected function:",
        "- Do not guess types or use placeholder fixes.",
        "- Use let _: Result<(), Error> if you must discard values but only after you've proven the call always returns Result.",
        "- Otherwise, explicitly annotate the return type, or unwrap safely (e.g., using .map(|_| ()), etc.)",
        "You are NOT allowed to patch over this by silencing the warning. You must fix the underlying type inference problem.",
        "3. Test and verify",
        "After each individual fix:",
        "cargo test redis_ops --nocapture",
        "Confirm the warning is completely gone",
        "If it's still there, your fix is wrong. Try again. No hand-waving.",
        "4. Commit",
        "After confirming the fix removes the warning, do:",
        "git add src/redis_ops.rs",
        "git commit -m \"fix: remove never-type fallback warning in store_file_content\"",
        "Repeat for each function. One commit per fix. Do not batch these.",
        "5. Final sweep",
        "Run a full test and confirm zero fallback warnings:",
        "cargo clean && cargo test --all --nocapture",
        "If any are left: go back and fix them. If none remain: move to the next workflow item.",
        "Absolutely forbidden",
        "- #[allow(warning)] or any compiler attribute meant to silence the warning",
        "- Comments downplaying the impact",
        "- Using let _ = just to shut the compiler up",
        "- Committing changes without confirming the warning is resolved",
        "This is not a discussion. This is not a debate. This is not \"just a warning.\" This is a countdown to failure in Rust 2024. Fix it or GTFO."
      ]
    },
    {
      "id": "require-test-after-each-change",
      "description": "Forces test validation for any code change within function scope. No change is too small to escape scrutiny.",
      "body": [
        "1. Trigger Conditions",
        "   Any edit inside a function\u2014including renames reorderings or doc changes\u2014triggers this workflow.",
        "   Applies to user or model edits. No bypass allowed.",
        "2. Immediate Actions",
        "   Identify the edited function and its containing module.",
        "   Check for associated tests. If none exist generate a placeholder test and halt execution.",
        "     Run all tests for that module immediately after the change.",
        "3. Enforcement",
        "   Do not proceed if any related test fails.",
        "   Do not accept 'trivial change' as a justification to skip testing.",
        "     Model must confirm test status in its output before continuing.",
        "4. Logging",
        "   Log every test run triggered by this workflow for audit.",
        "   Include filename function name and test results.",
        "5. Violation Handling",
        "   If code was modified and this workflow was not triggered flag the session for manual review.",
        "   Repeat offenders must be shamed with sarcastic commit messages.",
        "6. Documentation",
        "   Documentation is very very poor and must be improved. Focus all docs on the Rust implementation; do not add or update any documentation for the Python code.",
        "   After every successful test or bug fix update or create the corresponding documentation entry for the affected module/function."
      ]
    },
    {
      "id": "task-tracking-workflow",
      "description": "Project Task Tracking and Completion",
      "body": [
        "1. When a new task is identified (bug, feature, improvement), add it as a checkbox item to the \"Open Tasks\" section of .windsurf/tasks.md.",
        "2. When a task is completed, move it to the \"Completed Tasks\" section with a note referencing the commit or PR that resolved it.",
        "3. Review .windsurf/tasks.md before each handoff or release to ensure all tasks are up to date and no open tasks are forgotten.",
        "4. Do not close any task without a completion reference.",
        "5. If a task is urgent or blocks other work, mark it as **[priority]** in the list."
      ]
    },
    {
      "id": "tdd-workflow-feature-development-cycle",
      "description": "",
      "body": [
        "## Objective: Implement features or changes using a strict Red-Green-Refactor TDD cycle.",
        "Models WILL NOT write implementation code before defining and running a failing test.",
        "This workflow ensures compliance with TDD principles and integrates with existing rules like zero-warnings-required and task-tracking.",
        "## Phase 1: Task Definition & Test Specification (THE PLAN)",
        "1.  Identify Task: Ensure the current work corresponds to an open item in .windsurf/tasks.md. If not, create one. The task MUST clearly define the feature or behavior to be implemented or changed.",
        "2.  Specify Test Case(s): Before writing ANY test code, describe the test cases in plain language within the task item in .windsurf/tasks.md. Include:",
        "    - What function or module is being tested.",
        "    - Inputs to be provided.",
        "    - Expected outputs or behavior.",
        "    - How success or failure will be determined.",
        "3.  No Implementation Code: At this stage, models are FORBIDDEN from writing or modifying any application logic related to the feature.",
        "## Phase 2: Write Failing Test (RED)",
        "1.  Implement Test Code: Write the actual test code based on the specification from Phase 1. This test MUST target behavior not yet implemented or existing behavior that needs to change.",
        "    - Adhere to mandatory-testing every function gets a test.",
        "    - For async code, use the attribute tokio double_colon test.",
        "    - For dependencies e.g. Redis, use appropriate test doubles or stubs for unit tests or prepare for integration testing as per isolate-project-state and general advice on minimizing mocks.",
        "2.  Run Test & Confirm Failure: Execute the test e.g. cargo test your_new_test_name --nocapture.",
        "    - The test MUST FAIL. This is critical. It proves the test is valid and the behavior is not already present.",
        "    - Log the failure output as per logging-required-for-redis if applicable, or general test logs.",
        "3.  Commit Failing Test Optional but Recommended:",
        "    - git add path/to/test_file.rs",
        "    - git commit -m feat(TDD): Add failing test for specific_behavior_from_task",
        "## Phase 3: Write Minimal Code to Pass (GREEN)",
        "1.  Implement Application Code: Write the absolute MINIMUM amount of application code required to make the failing test from Phase 2 pass.",
        "    - Adhere to no-creative-output and no-free-thinking. Stick to the requirements.",
        "    - Ensure error-handling-and-logging and no-silent-errors are followed.",
        "2.  Run Tests: Execute all relevant tests e.g. cargo test --nocapture.",
        "    - The specific test from Phase 2 MUST now PASS.",
        "    - All other existing tests in the module or project MUST continue to PASS.",
        "    - There must be ZERO warnings, as per zero-warnings-required.",
        "3.  Iterate if Necessary: If tests do not pass, debug and modify ONLY the implementation code. Do not change the test unless it was flawed which should have been caught in Phase 2.",
        "## Phase 4: Refactor (CLEANUP)",
        "1.  Refactor Code: With all tests passing, refactor BOTH the implementation code and the test code for clarity, performance, and maintainability.",
        "    - Ensure idiomatic Rust async-modular-idiomatic-rust.",
        "    - Remove duplication.",
        "    - Improve names, structure, etc.",
        "2.  Run Tests Continuously: After each refactoring change, re-run all tests to ensure they remain GREEN and warning-free.",
        "    - If any test fails, the refactoring introduced a bug. Fix it immediately.",
        "3.  Commit Green & Refactored Code:",
        "    - git add .",
        "    - git commit -m feat: Implement specific_behavior_from_task and pass tests or fix:, refactor:, etc. as appropriate",
        "## Phase 5: Cycle Completion & Handoff",
        "1.  Verify All Rules: Confirm compliance with handoff-procedure, model-user-handoff, no-stubs-no-todos-no-future-work.",
        "2.  Update Task Tracker: Mark the item in .windsurf/tasks.md as completed, referencing the commits.",
        "3.  Proceed to the next task or request further instructions.",
        "## Strictly Forbidden in this Workflow:",
        "- Writing implementation code before a documented, failing test has been run and confirmed.",
        "- Modifying test code to make it pass without changing implementation code unless the test itself was fundamentally flawed.",
        "- Committing code that does not pass all tests or has warnings.",
        "- Ignoring any step of this Red-Green-Refactor cycle."
      ]
    },
    {
      "id": "test-and-commit-after-change",
      "description": "Forces test validation for any code change within function scope. No change is too small to escape scrutiny.",
      "body": [
        "Automates testing and committing every code change, even tiny fixes. Writes minimal tests, ensures they pass, and commits with git. Fast, diligent, avoids dumb errors. (134 chars)",
        "Trigger",
        "  Runs automatically after any code change (even a one liner) upon saving in Windsurf.",
        "Tasks",
        "  Write a Minimal Test",
        "  Write a quick, focused test for the change (e.g., test a tweaked function\u2019s output).",
        "  Keep it minimal\u2014no chaos tests, just enough to verify the fix.",
        "Run the Test",
        "  Execute the test in Windsurf\u2019s terminal (e.g., cargo test <module> nocapture).",
        "  If it fails, fix the code or test until it passes without breaking quality.",
        "Commit with Git",
        "  Commit the change and test: git commit m fix: <describe change, e.g., quack overflow>.",
        "  Keep the message clear and specific.",
        "Verify the Commit",
        "  Check the commit message isn\u2019t garbage.",
        "  Confirm only the changed file and test are committed.",
        "Rules",
        "  Redacted: Specify rules in the prompt.",
        "Automation",
        "  Hooks into Windsurf\u2019s save event (e.g., VS Code task or extension).",
        "Completion",
        "  Log test results, commit hash, and applied rules to .windsurf/logs/testandcommit.log.",
        "  Confirm workflow ran autonomously.",
        "  Reset for next change: monitor for new saves to loop back to Tasks."
      ]
    },
    {
      "id": "zero-warnings-model-accountable",
      "description": "Enforces zero warnings and full model accountability for code quality and test results. No excuses, no handoffs with defects.",
      "body": [
        "# Workflow: Zero Warnings, Zero Excuses, Model-Accountable Delivery",
        "## 1. Absolute Clean State Before Any Code Change",
        "- Run git status and git diff to ensure no uncommitted changes or untracked files pollute the working directory.",
        "- Stash or commit all unrelated changes before proceeding.",
        "## 2. Compilation and Test Baseline (Pre-Change)",
        "- Run cargo clean && cargo build and cargo test --all -- --nocapture before making any code changes.",
        "- If any warnings or test failures are present, the model must halt and address them **before** writing new code.",
        "- Document all pre-existing issues in .windsurf/logs/pre-change.log.",
        "## 3. Code Change Responsibility",
        "- The model, not the user, is responsible for all code changes, test results, and code hygiene.",
        "- The model must not defer, excuse, or minimize any warning or error. Every warning is a defect.",
        "- The model must not claim \"all is passing\" unless all output is green and free of warnings/errors.",
        "## 4. Post-Change Build and Test",
        "- After any code change, immediately run cargo build and cargo test --all -- --nocapture.",
        "- If **any** warning or error is present (yellow or red output), the model must:",
        "  - Halt further work.",
        "  - Triage and fix every warning and error, one by one, until the build and test output is 100% clean (green).",
        "  - Do not proceed with additional features, refactors, or tasks until all warnings are resolved.",
        "## 5. No Warning Left Behind",
        "- Warnings include, but are not limited to: unused variables, dead code, deprecated usage, redundant patterns, type inference issues, etc.",
        "- The model must fix all warnings, not silence them with attributes or ignore them.",
        "- If a warning cannot be fixed due to an upstream dependency, document it in .windsurf/tasks.md with justification and reference.",
        "## 6. Honest and Accurate Reporting",
        "- The model must never state \"all tests pass\" or \"build is clean\" if any warning or error is present.",
        "- If the user is seeing red or yellow, the model must acknowledge and address it, not contradict the user's terminal or CI output.",
        "- All status reports must be accurate, complete, and reflect the true state of the codebase as seen by the user.",
        "## 7. Commit and Documentation",
        "- Only commit changes when the build and test output is 100% clean (no warnings, no errors).",
        "- Each commit message must reference the specific warning/error fixed, and include a summary of the steps taken.",
        "- Update .windsurf/tasks.md and relevant logs to reflect all fixes and status.",
        "## 8. Handoff and Review",
        "- Before handing off to the user or another model, confirm all output is green.",
        "- Provide a summary of what was fixed, how, and include the final clean test/build logs.",
        "- If any warning or error remains, the handoff is not complete.",
        "**Deviation from this workflow is never permitted. Warnings are defects. The model is fully responsible for code quality and must never shift blame or responsibility to the user.**"
      ]
    }
  ]
}